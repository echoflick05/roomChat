class EchoFlickClient{constructor(e,t,n="public"){if("public"!==n&&"private"!==n)throw Error('Invalid type. It must be "public" or "private".');this.url="ws://18.237.74.53:8080?public_key="+e+"&channel_id="+t+"&channel_type="+n,this.ws=null,this.onOpenCallback=null,this.onMessageCallback=null,this.onServerCallback=null,this.onCloseCallback=null,this.onErrorCallback=null,this.onClientInGroup=null,this.messageQueue={},this.channelObject={type:"SEND_MESSAGE",groupName:null,fromChannelId:t,toChannelId:null,channelType:n,data:null,channelInfo:null}}connect(){this.ws=new WebSocket(this.url),this.ws.onopen=()=>{this.onOpenCallback&&this.onOpenCallback()},this.ws.onmessage=e=>{let t;try{t=JSON.parse(e.data)}catch(n){t=structuredClone(this.channelObject)}t?.type==="GET_ACTIVE_CHANNELS"?t.requestId&&this.messageQueue[t.requestId]&&(this.messageQueue[t.requestId](t),delete this.messageQueue[t.requestId]):t?.type==="SERVER_RESPONSE"?this.onErrorCallback&&this.onErrorCallback(e.data):t?.type==="ON_CLIENT_IN_GROUP"?this.onClientInGroup&&this.onClientInGroup(t):this.onMessageCallback&&this.onMessageCallback(t)},this.ws.onclose=()=>{this.onCloseCallback&&this.onCloseCallback()},this.ws.onerror=e=>{this.onErrorCallback&&this.onErrorCallback(e)}}sendMessage(e,t,n="INDIVIDUAL"){if("INDIVIDUAL"!==n&&"GROUP"!==n)throw Error('Invalid type. It must be "INDIVIDUAL" or "GROUP".');if(this.ws&&this.ws.readyState===WebSocket.OPEN){let s=this.typeHandle(e),l=structuredClone(this.channelObject);l.data=s,l.toChannelId="GROUP"===n?null:t,l.groupName="GROUP"===n?t:null,this.ws.send(JSON.stringify(l))}else channelInfo,console.error("WebSocket is not open. Cannot send message.")}typeHandle(e){let t;switch(typeof e){case"object":Array.isArray(e),t=JSON.stringify(e);break;case"string":case"number":case"boolean":case"bigint":case"undefined":t=e;break;default:t=String(e)}return t}onOpen(e){this.onOpenCallback=e}onMessage(e){this.onMessageCallback=e}onServerResponse(e){this.onServerCallback=e}onActiveChannels(e){this.onActiveChannelCallback=e}onClose(e){this.onCloseCallback=e}onClientGroup(e){this.onClientInGroup=e}onError(e){this.onErrorCallback=e}getActiveChannels(e=null){return new Promise((t,n)=>{let s=Date.now();this.messageQueue[s]=t;let l=structuredClone(this.channelObject);l.type="GET_ACTIVE_CHANNELS",l.groupName=e,l.requestId=s,this.ws.send(JSON.stringify(l)),setTimeout(()=>{this.messageQueue[s]&&(n("Request timed out"),delete this.messageQueue[s])},5e3)})}addGroup(e){let t=structuredClone(this.channelObject);t.type="ADD_GROUP",t.groupName=e,this.ws.send(JSON.stringify(t))}leaveGroup(e){let t=structuredClone(this.channelObject);t.type="LEAVE_GROUP",t.groupName=e,this.ws.send(JSON.stringify(t))}updateType(e){if("SEND_MESSAGE"!==e&&"GET_ACTIVE_CHANNELS"!==e)throw Error('Invalid type. It must be "GET_ACTIVE_CHANNELS" or "SEND_MESSAGE".');this.channelObject.type=e}updateChannelInfo(e){this.channelObject.channelInfo=e;let t=structuredClone(this.channelObject);t.type="UPDATE_INFO",this.ws.send(JSON.stringify(t))}}window.EchoFlickClient=EchoFlickClient;